
    <!DOCTYPE html>
    <html>
    <head>
      <meta charset="utf-8">
      <meta http-equiv="X-UA-Compatible" content="IE=edge">
      <!-- common.css -->
      <style>* {-webkit-tap-highlight-color: rgba(0,0,0,0);}html {-webkit-text-size-adjust: none;}body {font-family: -apple-system, Helvetica, Arial, sans-serif;margin: 0;padding: 20px;color: #333;word-wrap: break-word;}h1, h2, h3, h4, h5, h6 {line-height: 1.1;}img {max-width: 100% !important;height: auto;}blockquote {margin: 0;padding: 0 15px;color: #777;border-left: 4px solid #ddd;}hr {background-color: #ddd;border: 0;height: 1px;margin: 15px 0;}code {font-family: Menlo, Consolas, 'Ubuntu Mono', Monaco, 'source-code-pro', monospace;line-height: 1.4;margin: 0;padding: 0.2em 0;font-size: 90%;background-color: rgba(0,0,0,0.04);border-radius: 3px;}pre > code {margin: 0;padding: 0;font-size: 100%;word-break: normal;background: transparent;border: 0;}ol {list-style-type: decimal;}ol ol, ul ol {list-style-type: lower-latin;}ol ol ol, ul ol ol, ul ul ol, ol ul ol {list-style-type: lower-roman;}table {border-spacing: 0;border-collapse: collapse;margin-top: 0;margin-bottom: 16px;}table th {font-weight: bold;}table th, table td {padding: 6px 13px;border: 1px solid #ddd;}table tr {border-top: 1px solid #ccc;}table tr:nth-child(even) {background-color: #f8f8f8;}input[type="checkbox"] {cursor: default;margin-right: 0.5em;font-size: 13px;}.task-list-item {list-style-type: none;}.task-list-item+.task-list-item {margin-top: 3px;}.task-list-item input {float: left;margin: 0.3em 1em 0.25em -1.6em;vertical-align: middle;}#tag-field {margin: 8px 2px 10px;}#tag-field .tag {display: inline-block;background: #cadff3;border-radius: 4px;padding: 1px 8px;color: black;font-size: 12px;margin-right: 10px;line-height: 1.4;}</style>
      <!-- ace-static.css -->
      <style>.ace_static_highlight {white-space: pre-wrap;}.ace_static_highlight .ace_gutter {width: 2em;text-align: right;padding: 0 3px 0 0;margin-right: 3px;}.ace_static_highlight.ace_show_gutter > .ace_line {padding-left: 2.6em;}.ace_static_highlight .ace_line {position: relative;}.ace_static_highlight .ace_gutter-cell {-moz-user-select: -moz-none;-khtml-user-select: none;-webkit-user-select: none;user-select: none;top: 0;bottom: 0;left: 0;position: absolute;}.ace_static_highlight .ace_gutter-cell:before {content: counter(ace_line, decimal);counter-increment: ace_line;}.ace_static_highlight {counter-reset: ace_line;}</style>
      <style>.ace-chrome .ace_gutter {background: #ebebeb;color: #333;overflow : hidden;}.ace-chrome .ace_print-margin {width: 1px;background: #e8e8e8;}.ace-chrome {background-color: #FFFFFF;color: black;}.ace-chrome .ace_cursor {color: black;}.ace-chrome .ace_invisible {color: rgb(191, 191, 191);}.ace-chrome .ace_constant.ace_buildin {color: rgb(88, 72, 246);}.ace-chrome .ace_constant.ace_language {color: rgb(88, 92, 246);}.ace-chrome .ace_constant.ace_library {color: rgb(6, 150, 14);}.ace-chrome .ace_invalid {background-color: rgb(153, 0, 0);color: white;}.ace-chrome .ace_fold {}.ace-chrome .ace_support.ace_function {color: rgb(60, 76, 114);}.ace-chrome .ace_support.ace_constant {color: rgb(6, 150, 14);}.ace-chrome .ace_support.ace_type,.ace-chrome .ace_support.ace_class.ace-chrome .ace_support.ace_other {color: rgb(109, 121, 222);}.ace-chrome .ace_variable.ace_parameter {font-style:italic;color:#FD971F;}.ace-chrome .ace_keyword.ace_operator {color: rgb(104, 118, 135);}.ace-chrome .ace_comment {color: #236e24;}.ace-chrome .ace_comment.ace_doc {color: #236e24;}.ace-chrome .ace_comment.ace_doc.ace_tag {color: #236e24;}.ace-chrome .ace_constant.ace_numeric {color: rgb(0, 0, 205);}.ace-chrome .ace_variable {color: rgb(49, 132, 149);}.ace-chrome .ace_xml-pe {color: rgb(104, 104, 91);}.ace-chrome .ace_entity.ace_name.ace_function {color: #0000A2;}.ace-chrome .ace_heading {color: rgb(12, 7, 255);}.ace-chrome .ace_list {color:rgb(185, 6, 144);}.ace-chrome .ace_marker-layer .ace_selection {background: rgb(181, 213, 255);}.ace-chrome .ace_marker-layer .ace_step {background: rgb(252, 255, 0);}.ace-chrome .ace_marker-layer .ace_stack {background: rgb(164, 229, 101);}.ace-chrome .ace_marker-layer .ace_bracket {margin: -1px 0 0 -1px;border: 1px solid rgb(192, 192, 192);}.ace-chrome .ace_marker-layer .ace_active-line {background: rgba(0, 0, 0, 0.07);}.ace-chrome .ace_gutter-active-line {background-color : #dcdcdc;}.ace-chrome .ace_marker-layer .ace_selected-word {background: rgb(250, 250, 255);border: 1px solid rgb(200, 200, 250);}.ace-chrome .ace_storage,.ace-chrome .ace_keyword,.ace-chrome .ace_meta.ace_tag {color: rgb(147, 15, 128);}.ace-chrome .ace_string.ace_regex {color: rgb(255, 0, 0)}.ace-chrome .ace_string {color: #1A1AA6;}.ace-chrome .ace_entity.ace_other.ace_attribute-name {color: #994409;}.ace-chrome .ace_indent-guide {background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAACCAYAAACZgbYnAAAAE0lEQVQImWP4////f4bLly//BwAmVgd1/w11/gAAAABJRU5ErkJggg==") right repeat-y;}</style>
      <!-- export.css -->
      <style>
        body{margin:0 auto;max-width:800px;line-height:1.4}
        #nav{margin:5px 0 10px;font-size:15px}
        #titlearea{border-bottom:1px solid #ccc;font-size:17px;padding:10px 0;}
        #contentarea{font-size:15px;margin:16px 0}
        .cell{outline:0;min-height:20px;margin:5px 0;padding:5px 0;}
        .code-cell{font-family:Menlo,Consolas,'Ubuntu Mono',Monaco,'source-code-pro',monospace;font-size:12px;}
        .latex-cell{white-space:pre-wrap;}
      </style>
      <!-- User CSS -->
      <style> .text-cell {font-size: 15px;}.code-cell {font-size: 12px;}.markdown-cell {font-size: 15px;}.latex-cell {font-size: 15px;}</style>
    </head>
    <body>
      <div id="titlearea">
        <h2>CS231N - Lecture 16 - Adversarial Examples</h2>
      </div>
      <div id="contentarea"><div class="cell text-cell"><div>Adversarial Examples are not due to overfitting: [i.e. overfitting to parameter contours that the network only found in gibbon images].</div><div>Surprisingly, it has somethign deeper to do with CNNs themselves.</div><div>Goodfellow et al found that the same fooled image was able to output the wrong label on many different types of models, including the ones it was not trained on. In addition, the attack vector which is added to the original image to get the adversarial example could be added to any clean example and we would get an adversarial example in most cases.</div><div><br></div><div><b>Adversarial Examples are from Underfitting (Excessive Linearity)&nbsp;(Appendix 1)</b></div><div>The mapping from inputs to NN to outputs are piecewise linear. (The mapping from parameters to outputs are highly nonlinear becuase a lot of parameters are multiplied together).</div><div>The issue with linear functions (or piecewise linear functions) is that examples very far from the training data will be classified with veyr high probability, even though no data was ever seen in that subspace, just because of linear extrapolation. &nbsp;</div><div>They picked a random vector with which to adjust the image, and plotted the classification scores when adding different levels of the noise to the image. Because the model uses ReLU, the output is a piecewise lienar function of the input. But in fact, the output is very linear.</div><div><br></div><div>Small changes to individual pixels can add up to big changes after multiplying through all the layers of the neural network. You can make small changes that are almost inperceptible but that move you very far when measured by the L2 norm. When we make adversarial examples we limit the change to any particular pixel to a certain band (called the <b>maxnorm</b>) so that the changes cannot be concentrated in one place. The overall L2 norm difference might still be large. An easy way to do this is with the <b>fast gradient sign method</b>. (Apendix 1)</div><div><br></div><div><br></div><div><img src="resources/AE68467D0C2A6C82F79DB1DD95676BC4.png" alt="Screenshot 2020-03-28 at 5.48.14 PM.png" width="714" height="501"><br></div><div><br></div><div><b>Appendix 1:</b></div><div><div><div>All models are extremely easy to fool, not just deep models. Linear models, decision trees can all be fooled in this way.</div><div>Suppose we have an image on the left is 60% classified as a Panda. After adding the attack adjustment, it is classified with 99.9% confidence that it is a gibbon.</div></div><div><img src="resources/9D5A95D44D29C770E1A8CFA2C58B059A.png" alt="Screenshot 2020-03-28 at 5.44.17 PM.png" width="710" height="190"></div></div><div><br></div><div><img src="resources/8F6C973E657AA9A638BBC99B6D5DB7A2.png" alt="Screenshot 2020-03-28 at 5.44.44 PM.png" width="660" height="506"><br></div><div><img src="resources/2FE92671C994E563F0E7D0D61DE01FA7.png" alt="Screenshot 2020-03-28 at 5.45.33 PM.png" width="704" height="524"></div><div><br></div><div><img src="resources/2E63E21E02FB19704B2DD3018A525D40.png" alt="Screenshot 2020-03-28 at 6.02.15 PM.png" width="669" height="473"><br></div><div>The Fast Gradient Sign Method has identified a direction where if we get a large dot product with that direction, we can get an adversarial example.&nbsp;</div><div>Adversarial examples live in linear subspaces. Nearly every linear example is near an adversarial example, and once you move into that subspace, it remains an adversarial example however far you go.</div><div>Security implications: you don’t need to get the magnitude right to make an adversarial example: You only need to get the direciton right. Once you move more or less approx to that direction you can fool the model.</div><div><br></div><div><img src="resources/500ED69BC305ABB0E17D86AC4AB9ED60.png" alt="Screenshot 2020-03-28 at 6.05.21 PM.png" width="710" height="530"><br></div><div>Adversarial Examples are not Noise - adding noise preserves classification decision in most cases.</div><div><img src="resources/1F4C160A8DE7EBEB181EBDB6BC992E72.png" alt="Screenshot 2020-03-28 at 6.09.50 PM.png" width="713" height="536"><br></div><div>In high dimensional spaces, if you choose a reference vector and a random vector in that space, the random vector will on average have a zero dot product with the reference vector. On average, random examples have zero effect on the cost, but adversatial examples are chosen to maximize it.</div><div>The adversarial subspace have on average 25 dimensions on MNIST.</div><div><br></div><div>Adversarial examples work across multiple models because the overlap between the adversarial subspaces are quite large. Even though they are only 25 dimensional compared to a 3000-dimensional image, the adversarial subspaces tend to be highly dependent on the image classes, for example “pointing from one class centroid to another class centroid”. This increases the probability that the adversarial subspaces of two models overlap. If two different models have a very large adversarial subspace, you know you can transfer adversarial examples fron one to another.<br></div><div><br></div><div><img src="resources/B1B0156A1280548F9182DB041CD4D7AE.png" alt="Screenshot 2020-03-28 at 6.12.21 PM.png" width="716" height="532"><br></div><div><br></div><div><br></div><div>Moden ML ALgorithms are like Clever Hans, the horse that folled everyone by doing arithmetic. They are wrong almost everywhere.</div><div>They are correct on naturally occuring input, that is, input that is distributed i.i.d. according to the same distribution of the data they were trained on. But outside of that data manifold, on random data, they are wrong almost everywhere.&nbsp;</div><div><img src="resources/75354C686FFE7D24254DCE58B9F74209.png" alt="Screenshot 2020-03-28 at 6.17.28 PM.png" width="689" height="484"><br></div><div>Pink Box - classified as somethign rather than nothing.</div><div>Yellow Box - Fast Gradient Sign Method can make it think it’s an airplane.</div><div><br></div><div><b>Universal Adversarial Pertubations</b><br></div><div>Below: Logistic regression model that discriminates between 7 and 3. the FGSM attack on the image is just adding the sign of the weights.</div><div>When the sign of weights is positive the image looks like the most quintisential 7, when negative, it will look like the most quintisential 3.</div><div><img src="resources/C6A3F68D58EAE39D21BE4DC5AF87169C.png" alt="Screenshot 2020-03-28 at 6.29.13 PM.png" width="703" height="489"><img src="resources/124CE782AD79B27AE8BBDB62E8A7CB20.png" alt="Screenshot 2020-03-28 at 6.32.32 PM.png" width="706" height="388"><br></div><div>You can do the same thing on ImageNet. This one uses the daisy class. This filter when added to any image is able to make the image be interpreted as a daisy.</div><div><br></div><div>Quadratic networks (<b>shallow rbf network</b>) is able to resist adversarial examples really well.</div><div>But Deep RBF networks are essentially super hard to train, the quadratic term makes the gradient 0 almost always.&nbsp;</div><div><br></div><div><b>Adversarial Examples Transferability</b></div><div>Adversarial exampels generaize from dataset to dataset. Imaging an attacker wants to fool a model, but they don’t know what model architecture is, they don’t know what algorithm (decision tree or DNN), and they also don’t know the parameters.</div><div><br></div><div><br></div><div><img src="resources/F3ECE5A39B5C76C0BCA6564F2BA08A26.png" alt="Screenshot 2020-03-28 at 6.35.56 PM.png" width="682" height="488"><br></div></div><div class="cell text-cell">They can train their own model to create an attack, make adversarial examples on your model, and with high probability fool the original model without any access to it.&nbsp;<div><img src="resources/851D2BB1879B9A3D83FE76E23427D35F.png" alt="Screenshot 2020-03-28 at 6.36.15 PM.png" width="704" height="529"><img src="resources/3B6512B75A01403ED2C776495DD131F0.png" alt="Screenshot 2020-03-28 at 6.38.43 PM.png" width="683" height="466"></div><div>Dawn Song’s group -&nbsp;</div><div>If you do an Ensemble of many models, and make an adversarial examples, theres a very high probability that your adversarial example will generalize to new models.</div><div><br></div><div>You can print out adversarial examples and the new physical version will also fool computer vision models.</div><div><br></div><div><img src="resources/0956F686CCA6C4ACEA4CDE2CC80A222A.png" alt="Screenshot 2020-03-28 at 6.42.20 PM.png" width="707" height="523"></div><div><br></div><div><img src="resources/C1292EBE60465AA741760AB51FC0BEDA.png" alt="Screenshot 2020-03-28 at 6.43.22 PM.png" width="710" height="524"></div><div><img src="resources/1766BFD3DC6189893636D601B3C3FE5B.png" alt="Screenshot 2020-03-28 at 6.43.37 PM.png" width="688" height="518"><br></div><div><br></div><div>Left: Mixture of two Gaussians, Right: Mixture of two Laplacians, Model: Logistic Regresson</div><div><br></div><div><b>Adversarial Training</b></div><div>A partial solution: Training on adversarial examples can make models partially more robust. Adversarial training is a very data hungry and compute hungry process, because with each iteration you need to update the adversarial examples with whatever it is that the model has learned recently.</div><div><img src="resources/A7DF6C6B24BEC02D0AA80868AEC2F514.png" alt="Screenshot 2020-03-28 at 6.45.52 PM.png" width="703" height="518"><br></div><div><br></div><div>Adversarial training provides regularization and semi-supervised learning.</div><div><br></div><div><b>Virtual Adversarial Training:&nbsp;</b></div><div>If we solve adversarial examples, we could do model-based optimization.<br></div><div><br></div><div style="font-size: 17px;"><b>High level Idea:</b></div><div style="font-size: 14px;">Neural networks are not just brittle from overfitting (see a bunch of cases and not generalise becase you don’t correctly parameterize the input distribution), they are also brittle from underfitting.&nbsp;</div><div style="font-size: 14px;"><br></div><div style="font-size: 14px;">Could human thought processes be the same? Overfitting produces nonsense cognition but underfitting means we study everything on a small manifold which is the real world but we dont realize that that is on a much bigger manifold/space.&nbsp;</div><div><br></div></div><div class="cell text-cell"></div></div>
    </body>
    </html>
  